graph_attributes$Gamma[edges_lst[3], 393]
graph_attributes$Gamma[edges_lst[3], 393]
state <- simulate_epidemic(graph_attributes$W,
y_init = y_init,
beta = beta_epid,
gamma = gamma_epid,
steps = steps,
heterogeneity_rates = heterogeneity_rates)
state$true_p[subject_0]
state$true_p[neighbors]
print(lambda)
lambda = 1
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
p_hat
p_hat[neighbors]
p_hat[subject_0]
lambda = 0.1
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
#  p_hat[neighbors]
p_hat[subject_0]
lambda = 0.001
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
#  p_hat[neighbors]
p_hat[subject_0]
p_hat[neighbors]
p_hat
lambda
lambda = 0.005
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
lambda = 0.0001
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
lambda = 0.005
lambda = 0.0005
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
graph_attributes$Gamma
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
edges$X1[1]
infection_weight =
edges["weights"]= weights
# Make beta_v into a matrix
for (e in 1:nrow(edges)){
W[edges$X1[e], edges$X2[e]] = edges$weights[e] * beta_v[edges$X1[e]]
W[edges$X2[e], edges$X1[e]] = edges$weights[e] * beta_v[edges$X2[e]]
Gamma[e,edges$X1[e]] = edges$weights[e] * (beta_v[edges$X2[e]] + beta_v[edges$X1[e]])/2
Gamma[e,edges$X2[e]] = - edges$weights[e] * (beta_v[edges$X2[e]] + beta_v[edges$X1[e]])/2
}
beta_v
Gamma
get_edge_incidence <- function(g, beta_v,
graph = "SBM", Theta=NULL,
Z = NULL, weight = 1){
n_nodes = vcount(g)
edges = data.frame(as_edgelist(g)) %>%
arrange(X1, X2)
W = matrix(0, nrow = n_nodes, ncol=n_nodes)
Gamma = matrix(0, nrow(edges), n_nodes)
if (graph  != "SBM"){
if (weight == 1) {
weights = rep(1, nrow(edges))
} else {
weights = runif(n=nrow(edges), min = 0.5, max=1)
}
}else{
weights = sapply(1:nrow(edges), function(i){Theta[Z[edges$X1[i]], Z[edges$X2[i]]]})
}
infection_weight =
edges["weights"]= weights
# Make beta_v into a matrix
for (e in 1:nrow(edges)){
W[edges$X1[e], edges$X2[e]] = edges$weights[e] * beta_v[edges$X1[e]]
W[edges$X2[e], edges$X1[e]] = edges$weights[e] * beta_v[edges$X2[e]]
Gamma[e,edges$X1[e]] = edges$weights[e] * (beta_v[edges$X2[e]] + beta_v[edges$X1[e]])/2
Gamma[e,edges$X2[e]] = - edges$weights[e] * (beta_v[edges$X2[e]] + beta_v[edges$X1[e]])/2
}
return(list(Gamma=Gamma,
W = W))
}
state <- simulate_epidemic(graph_attributes$W,
y_init = y_init,
beta = beta_epid,
gamma = gamma_epid,
steps = steps,
heterogeneity_rates = heterogeneity_rates)
state
state$true_p
state$true_p[neighbors]
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
which(graph_attributes$Gamma[, subject_0]!=0)
which(graph_attributes$Gamma[which(graph_attributes$Gamma[, subject_0]!=0),]!=0)
which(graph_attributes$Gamma[which(graph_attributes$Gamma[, subject_0]!=0),]!=0, arr.ind = TRUE)
subject_0
graph_attributes$Gamma[which(graph_attributes$Gamma[which(graph_attributes$Gamma[, subject_0]!=0), c(124, 325, 393)]
()
graph_attributes$Gamma[which(graph_attributes$Gamma[, subject_0]!=0), c(124, 325, 393)]
lambda
lambda = 5e-3
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
p_hat
lambda = 1e-3
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
graph_attributes$Gamma
source("~/Documents/epidemic_modelling/graph_utils.R")
state <- simulate_epidemic(graph_attributes$W,
y_init = y_init,
beta = beta_epid,
gamma = gamma_epid,
steps = steps,
heterogeneity_rates = heterogeneity_rates)
graph_attributes <- get_edge_incidence(g, state$beta_v, graph = "PA", weight=1)
graph_attributes$Gamma
graph_attributes$Gamma[1,1:10]
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
lambda
lambda = 0.002
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
lambda= 0.004
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda)
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
neighbors
subject_0
neighbors
help(cvxr_norm)
cvx_solver <- function(y_observed, Gamma, lambda, p_norm = 1){
n_nodes <- length(y_observed)
#print(n_edges)
#print(lambda)
p <- Variable(n_nodes)
constraints <- list(p >= 0, p <= 1)
# Define the quadratic loss
loss <- sum((y_observed - p)^2) / n_nodes
# Define the L-1 norm term
l1_norm <- cvxr_norm(Gamma %*% p, p = p_norm)
# Define the objective
objective <- Minimize(loss + lambda * l1_norm)
# Formulate the problem
problem <- Problem(objective, constraints)
# Solve the problem
result_problem <- solve(problem)
# Get the optimal value of p
p_opt <- result_problem$getValue(p)
return(p_opt)
}
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm=1)
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm="inf")
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
lambda
lambda = 0.001
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm="inf")
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
lambda = 0.0001
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm="inf")
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
lambda
lambda = 0.0005
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm="inf")
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
p_hat
graph_attributes$Gamma
graph_attributes$Gamma[1,]
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm="inf")
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
lambda
lambda = 0.001
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm="inf")
p_hat[which(p_hat <0)]=0
p_hat[neighbors]
p_hat[subject_0]
p_hat
p_hat[which(abs(p_hat) <1e-10)]=0
p_hat
p_hat[neighbors]
p_hat[subject_0]
lambda
lambda = 0.01
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm="inf")
p_hat[which(p_hat <0)]=0
p_hat[which(abs(p_hat) <1e-10)]=0
p_hat[neighbors]
p_hat[subject_0]
p_hat
lambda = 0.1
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm="inf")
p_hat[which(p_hat <0)]=0
p_hat[which(abs(p_hat) <1e-10)]=0
p_hat[neighbors]
p_hat[subject_0]
cvx_solver <- function(y_observed, Gamma, lambda, p_norm = 1){
n_nodes <- length(y_observed)
#print(n_edges)
#print(lambda)
subject_0 = which(y_observed!=0)
p <- Variable(n_nodes - 1)
constraints <- list(p >= 0, p <= 1, p[subject_0] == 1)
# Define the quadratic loss
loss <- sum((y_observed - p)^2) / n_nodes
# Define the L-1 norm term
l1_norm <- cvxr_norm(Gamma %*% p, p = p_norm)
# Define the objective
objective <- Minimize(loss + lambda * l1_norm)
# Formulate the problem
problem <- Problem(objective, constraints)
# Solve the problem
result_problem <- solve(problem)
# Get the optimal value of p
p_opt <- result_problem$getValue(p)
return(p_opt)
}
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm="inf")
y_observed
Gamma
Gamma = graph_attributes$Gamma
Gamma
p_norm
p_norm = 1
n_nodes <- length(y_observed)
#print(n_edges)
#print(lambda)
subject_0 = which(y_observed!=0)
subject_0
#print(n_edges)
#print(lambda)
subject_0 = which(y_observed!=0)
p <- Variable(n_nodes)
constraints <- list(p >= 0, p <= 1, p[subject_0] == 1)
# Define the quadratic loss
loss <- sum((y_observed - p)^2) / n_nodes
# Define the L-1 norm term
l1_norm <- cvxr_norm(Gamma %*% p, p = p_norm)
# Define the objective
objective <- Minimize(loss + lambda * l1_norm)
# Formulate the problem
problem <- Problem(objective, constraints)
# Solve the problem
result_problem <- solve(problem)
# Get the optimal value of p
p_opt <- result_problem$getValue(p)
cvx_solver <- function(y_observed, Gamma, lambda, p_norm = 1){
n_nodes <- length(y_observed)
#print(n_edges)
#print(lambda)
subject_0 = which(y_observed!=0)
p <- Variable(n_nodes)
constraints <- list(p >= 0, p <= 1, p[subject_0] == 1)
# Define the quadratic loss
loss <- sum((y_observed - p)^2) / n_nodes
# Define the L-1 norm term
l1_norm <- cvxr_norm(Gamma %*% p, p = p_norm)
# Define the objective
objective <- Minimize(loss + lambda * l1_norm)
# Formulate the problem
problem <- Problem(objective, constraints)
# Solve the problem
result_problem <- solve(problem)
# Get the optimal value of p
p_opt <- result_problem$getValue(p)
return(p_opt)
}
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm="inf")
p_hat
p_hat[which(p_hat <0)]=0
p_hat[which(abs(p_hat) <1e-10)]=0
p_hat[neighbors]
p_hat[subject_0]
p_hat[subject_0]
p_hat[subject_0]
p_hat[subject_0] * 10
source("~/Documents/epidemic_modelling/r/solvers/cvx_solver.R")
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm="inf")
p_hat[which(p_hat <0)]=0
p_hat[which(abs(p_hat) <1e-10)]=0
p_hat[neighbors]
p_hat[subject_0]
p_hat
p_hat[which(abs(p_hat) <1e-7)]=0
p_hat
neighbors <- as.numeric(neighborhood(g, nodes = c(subject_0), mindist=1)[[1]])
p_hat[neighbors]
neighbors
library(tidyverse)
library(igraph)
source("graph_utils.R")
source("experiments/evaluate_solution.R")
source("experiments/simulate_epidemic.R")
source("r/solvers/cvx_solver.R")
# Parameters
args <- commandArgs(trailingOnly = TRUE)
source("~/Documents/epidemic_modelling/debug_params.R")
# Create random graph
g <- sample_pa(n, power = power_pa, directed = FALSE)
if (do_plot) {
layout <- layout_with_fr(g)
plot(g, layout = layout, vertex.size = 4,
edge.arrow.size = 0, vertex.label = NA)
}
# Assign initial patients
y_init <- rep(0, n)
subject_0 <- sample(1:n, nb_init)
y_init[subject_0] <- 1
# Record statistics on the initial patients
d <- degree(g, v = subject_0,
mode = "total", loops = TRUE,
normalized = FALSE)
btw <- betweenness(g, v = subject_0)
cls <- closeness(g, v = subject_0)
d
neighbors <- as.numeric(neighborhood(g, nodes = c(subject_0), mindist=1)[[1]])
neighbors
print(neighbors)
graph_attributes$W[subject_0, neighbors]
state <- simulate_epidemic(graph_attributes$W,
y_init = y_init,
beta = beta_epid,
gamma = gamma_epid,
steps = steps,
heterogeneity_rates = heterogeneity_rates)
state
graph_attributes <- get_edge_incidence(g, state$beta_v, graph = "PA", weight=1)
graph_attributes
graph_attributes$W[subject_0, neighbors]
lambda = 0.01
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm="inf")
p_hat
p_hat[which(p_hat <0)]=0
p_hat[which(abs(p_hat) <1e-7)]=0
p_hat[neighbors]
p_hat[subject_0]
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm=1)
p_hat[which(p_hat <0)]=0
p_hat[which(abs(p_hat) <1e-7)]=0
p_hat[neighbors]
p_hat[subject_0]
res_temp <- evaluate_solution(state$y_observed,
p_hat,
state$true_p,
graph_attributes$Gamma)
p_hat[which(p_hat <0)]=0
p_hat[which(abs(p_hat) <1e-7)]=0
lambda =0.0001
p_norm = "inf"
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm=p_norm)
lambda
lambda = 1e-3
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm=p_norm)
p_norm = "inf"
print(lambda)
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm=p_norm)
graph_attributes$Gamma
lambda = 0.01
p_hat <- cvx_solver(y_init,
graph_attributes$Gamma,
lambda, p_norm=p_norm)
p_hat[which(p_hat <0)]=0
p_hat[which(abs(p_hat) <1e-7)]=0
p_hat[neighbors]
p_hat[subject_0]
p_hat
neighbors2 <- as.numeric(neighborhood(g, order=2, nodes = c(subject_0), mindist=2)[[1]])
neighbors2
p_hat[neighbors2]
p_hat[neighbors]
p_hat[neighbors2]
p_hat[subject_0]
lambda
e
# Propagate solution
prop_sol <- propagate_solution(graph_attributes$W, p_hat, state$beta_v,
state$gamma_v, 20)
prop_sol
propagate_solution <- function(W, p_hat, beta_v, gamma_v, nb_steps) {
p_current <- p_hat
list_p <- vector("list", nb_steps)
for (it in 1:nb_steps){
prop_results <- propagate_one_step(W, as.numeric(p_current), beta_v, gamma_v)
p_current <- sapply(prop_results$true_p, function(x){min(max(x,0), 1)})
list_p[[it]] <- p_current
}
return(list_p)
}
# Propagate solution
prop_sol <- propagate_solution(graph_attributes$W, p_hat, state$beta_v,
state$gamma_v, 20)
prop_sol
# Propagate real data
prop_truth <- propagate_solution(graph_attributes$W, y_init,
state$beta_v, state$gamma_v, 20)
prop_truth
# Compare the two
for (it in 1:20){
res_temp[ paste0("l1_propagated_error_", it)] = mean(abs(prop_truth[[it]] - prop_sol[[it]]))
res_temp[ paste0("l2_propagated_error_", it)] = mean((prop_truth[[it]] - prop_sol[[it]])^2)
}
res_temp
